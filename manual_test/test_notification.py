from manual_test_base import ManualTestBase, handle_command_line, CLEAN_SERVER_RECORD_TYPE, POPULATED_SERVER_RECORD_TYPE

SERVICE_NAME = 'Notification'
GET_ADDRESS_GROUPS_ROUTE = '/ninotification/v1/address-groups'
GET_MESSAGE_TEMPLATES_ROUTE = '/ninotification/v1/message-templates'
GET_NOTIFICATION_STRATEGIES_ROUTE = '/ninotification/v1/notification-strategies'
CREATE_ADDRESS_GROUP_ROUTE = '/ninotification/v1/address-groups'
CREATE_MESSAGE_TEMPLATES_ROUTE = '/ninotification/v1/message-templates'
CREATE_NOTIFICATION_STRATEGY_ROUTE = '/ninotification/v1/notification-strategies'


class TestNotification(ManualTestBase):
    def populate_data(self):
        address_groups = self.__populate_address_groups()
        message_templates = self.__populate_message_templates()
        self.__populate_notification_strategies(address_groups, message_templates)
        self.__record_data(POPULATED_SERVER_RECORD_TYPE)

    def record_initial_data(self):
        self.__record_data(CLEAN_SERVER_RECORD_TYPE)

    def validate_data(self):
        self.__validate_address_groups()
        self.__validate_message_templates()
        self.__validate_notification_strategies()

    def __record_data(self, record_type):
        self.record_data(SERVICE_NAME, 'address_groups', record_type, self.__get_all_address_groups())
        self.record_data(SERVICE_NAME, 'message_templates', record_type, self.__get_all_message_templates())
        self.record_data(SERVICE_NAME, 'notification_strategies', record_type, self.__get_all_notification_strategies())

    def __get_all_address_groups(self) -> list:
        response = self.get(GET_ADDRESS_GROUPS_ROUTE)
        response.raise_for_status()

        return response.json()

    def __populate_address_groups(self) -> list:
        created_groups = []
        groups_to_create = self.__get_expected_address_groups()
        for address_group in groups_to_create:
            response = self.post(CREATE_ADDRESS_GROUP_ROUTE, json=address_group)
            response.raise_for_status()
            created_groups.append(response.json())

        return created_groups

    def __validate_address_groups(self):
        source_service_snapshot = self.read_recorded_data(
            SERVICE_NAME,
            'address_groups',
            POPULATED_SERVER_RECORD_TYPE,
            required=True)
        target_service_snaphot = self.read_recorded_data(
            SERVICE_NAME,
            'address_groups',
            CLEAN_SERVER_RECORD_TYPE,
            required=False)
        current_snapshot = self.__get_all_address_groups()

        migrated_record_count = 0
        for group in current_snapshot:
            expected_group = self.__find_matching_record(group, source_service_snapshot)
            if expected_group is not None:
                self.__assertAddressGroupsEqual(expected_group, group, exact=True)
                migrated_record_count = migrated_record_count + 1
            else:
                # Verify items that are generated by the target version and not present in the source.
                expected_group = self.__find_matching_record(group, target_service_snaphot)
                assert expected_group is not None
                self.__assertAddressGroupsEqual(expected_group, group, exact=False)

        assert len(source_service_snapshot) == migrated_record_count

    def __get_expected_address_groups(self) -> list:
        address_groups = []
        for i in range(3):
            address_groups.append({
                'interpretingServiceName': 'Smtp',
                'displayName': f'Address Group {i}',
                'fields': self.__get_expected_smtp_address_group_fields(i),
                'properties': {'forTest': 'True'}
            })

        return address_groups

    def __assertAddressGroupsEqual(self, expected, actual, exact: bool):
        if exact:
            assert expected == actual
        else:
            assert expected['interpretingServiceName'] == actual['interpretingServiceName']
            assert expected['displayName'] == actual['displayName']
            assert expected['fields'] == actual['fields']
            assert expected['properties'] == actual['properties']

    def __get_expected_smtp_address_group_fields(self, index) -> dict:
        return {'toAddresses': [f'user{index}@example.com']}

    def __get_all_message_templates(self) -> list:
        response = self.get(GET_MESSAGE_TEMPLATES_ROUTE)
        response.raise_for_status()

        return response.json()

    def __populate_message_templates(self) -> list:
        created_templates = []
        templates_to_create = self.__get_expected_message_templates()
        for template in templates_to_create:
            response = self.post(CREATE_MESSAGE_TEMPLATES_ROUTE, json=template)
            response.raise_for_status()
            created_templates.append(response.json())

        return created_templates

    def __validate_message_templates(self):
        source_service_snapshot = self.read_recorded_data(
            SERVICE_NAME,
            'message_templates',
            POPULATED_SERVER_RECORD_TYPE,
            required=True)
        target_service_snaphot = self.read_recorded_data(
            SERVICE_NAME,
            'message_templates',
            CLEAN_SERVER_RECORD_TYPE,
            required=False)
        current_snapshot = self.__get_all_message_templates()

        migrated_record_count = 0
        for template in current_snapshot:
            expected_template = self.__find_matching_record(template, source_service_snapshot)
            if expected_template is not None:
                self.__assertMessageTemplatesEqual(expected_template, template, exact=True)
                migrated_record_count = migrated_record_count + 1
            else:
                # Verify items that are generated by the target version and not present in the source.
                expected_template = self.__find_matching_record(template, target_service_snaphot)
                assert expected_template is not None
                self.__assertMessageTemplatesEqual(expected_template, template, exact=False)

        assert len(source_service_snapshot) == migrated_record_count

    def __get_expected_message_templates(self) -> list:
        message_templates = []
        for i in range(5):
            message_templates.append({
                'interpretingServiceName': 'Smtp',
                'displayName': f'Message Template {i}',
                'fields': self.__get_example_smtp_message_template_fields(i),
                'properties': {'forTest': 'True'}
            })

        return message_templates

    def __assertMessageTemplatesEqual(self, expected, actual, exact: bool):
        if exact:
            assert expected == actual
        else:
            assert expected['interpretingServiceName'] == actual['interpretingServiceName']
            assert expected['displayName'] == actual['displayName']
            assert expected['fields'] == actual['fields']
            assert expected['properties'] == actual['properties']

    def __get_example_smtp_message_template_fields(self, index) -> dict:
        fields = {}
        fields['subjectTemplate'] = f'Sample subject template {index}'
        fields['bodyTemplate'] = f'Sample body template {index}'

        return fields

    def __get_all_notification_strategies(self) -> list:
        response = self.get(GET_NOTIFICATION_STRATEGIES_ROUTE)
        response.raise_for_status()

        return response.json()

    def __populate_notification_strategies(self, address_groups, message_templates) -> list:
        created_strategies = []
        strategies_to_create = self.__get_expected_notification_strategies(address_groups, message_templates)
        for strategy in strategies_to_create:
            response = self.post(CREATE_NOTIFICATION_STRATEGY_ROUTE, json=strategy)
            response.raise_for_status()
            created_strategies.append(response.json())

        return created_strategies

    def __validate_notification_strategies(self):
        source_service_snapshot = self.read_recorded_data(
            SERVICE_NAME,
            'notification_strategies',
            POPULATED_SERVER_RECORD_TYPE,
            required=True)
        target_service_snaphot = self.read_recorded_data(
            SERVICE_NAME,
            'notification_strategies',
            CLEAN_SERVER_RECORD_TYPE,
            required=False)
        current_snapshot = self.__get_all_notification_strategies()

        migrated_record_count = 0
        for strategy in current_snapshot:
            expected_strategy = self.__find_matching_record(strategy, source_service_snapshot)
            if expected_strategy is not None:
                self.__assertNotificationStrategiesEqual(expected_strategy, strategy, exact=True)
                migrated_record_count = migrated_record_count + 1
            else:
                # Verify items that are generated by the target version and not present in the source.
                expected_strategy = self.__find_matching_record(strategy, target_service_snaphot)
                assert expected_strategy is not None
                self.__assertNotificationStrategiesEqual(expected_strategy, strategy, exact=False)

        assert len(source_service_snapshot) == migrated_record_count

    def __get_expected_notification_strategies(self, address_groups, message_templates) -> list:
        notification_strategies = []
        for i in range(len(address_groups)):
            address_group_id = address_groups[i]['id']
            for j in range(len(message_templates)):
                index = i * len(message_templates) + j
                message_template_id = message_templates[j]['id']
                notification_strategies.append({
                    'displayName': f'Notification Strategy {index}',
                    'description': f'Description {index}',
                    'properties': {'forTest': 'True'},
                    'notificationConfigurations': [{
                        'addressGroupId': address_group_id,
                        'messageTemplateId': message_template_id,
                        'isExpanded': False,
                        'addressGroup': None,
                        'messageTemplate': None
                    }]
                })

        return notification_strategies

    def __assertNotificationStrategiesEqual(self, expected, actual, exact: bool):
        if exact:
            assert expected == actual
        else:
            assert expected['displayName'] == actual['displayName']
            assert expected['description'] == actual['description']
            assert expected['properties'] == actual['properties']

    def __find_matching_record(self, record, collection):
        return next((item for item in collection if item['id'] == record['id']), None)


if __name__ == '__main__':
    handle_command_line(TestNotification)
