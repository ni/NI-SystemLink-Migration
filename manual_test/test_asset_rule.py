from typing import Any, Dict, List, Optional
from manual_test.manual_test_base import \
    ManualTestBase, \
    handle_command_line, \
    CLEAN_SERVER_RECORD_TYPE, \
    POPULATED_SERVER_RECORD_TYPE
from manual_test.utilities.notification_utilities import NotificationUtilities
from manual_test.utilities.workspace_utilities import WorkspaceUtilities

SERVICE_NAME = 'AssetPerformanceManagementRuleEngine'
ASSET_RULE_DATABASE_NAME = 'niapmrule'
TEST_NAME = 'AssetRuleMigrationTest'
GET_CALIBRATION_RULES_ROUTE = 'niapmrule/v1/calibration-rules'
MODIFY_CALIBRATION_RULES_ROUTE_FORMAT = 'niapmrule/v1/calibration-rules/{rule_id}'


class TestAssetRule(ManualTestBase):

    def populate_data(self) -> None:
        notification_strategy_id = self.__create_test_notification_strategy()
        workspace_utilities = WorkspaceUtilities()
        workspace_utilities.create_workspace_for_test(self)

        # The API does not allow us to create new rules, so add a new handler
        # to the existing rules.
        existing_rules = self.__get_all_rules()
        for workspace_id in workspace_utilities.get_workspaces(self):
            self.__modify_existing_rule(workspace_id, notification_strategy_id, existing_rules)

        self.record_json_data(
            SERVICE_NAME,
            ASSET_RULE_DATABASE_NAME,
            POPULATED_SERVER_RECORD_TYPE,
            self.__get_all_rules())

    def record_initial_data(self) -> None:
        self.record_json_data(
            SERVICE_NAME,
            ASSET_RULE_DATABASE_NAME,
            CLEAN_SERVER_RECORD_TYPE,
            self.__get_all_rules())

    def validate_data(self) -> None:
        source_service_snapshot = self.read_recorded_json_data(
            SERVICE_NAME,
            ASSET_RULE_DATABASE_NAME,
            POPULATED_SERVER_RECORD_TYPE,
            required=True)
        target_service_snaphot = self.read_recorded_json_data(
            SERVICE_NAME,
            ASSET_RULE_DATABASE_NAME,
            CLEAN_SERVER_RECORD_TYPE,
            required=False)
        current_snapshot = self.__get_all_rules()

        workspaces = WorkspaceUtilities().get_workspaces(self)
        notification_strategies = NotificationUtilities().get_all_notification_strategies(self)

        migrated_record_count = 0
        for rule in current_snapshot:
            expected_rule = self.find_record_with_matching_id(rule, source_service_snapshot)
            if expected_rule is not None:
                self.__assert_rules_equal(expected_rule, rule, strict=True)
                self.__assert_rule_has_valid_workspace(rule, workspaces)
                self.__assert_rule_has_valid_notification_strategies(rule, notification_strategies)
                migrated_record_count = migrated_record_count + 1
            else:
                # Verify items that are generated by the target version and not present in the source.
                expected_rule = self.__find_rule_by_display_name(rule, target_service_snaphot)
                assert expected_rule is not None
                self.__assert_rules_equal(expected_rule, rule, strict=False)
                self.__assert_rule_has_valid_workspace(rule, workspaces)
                self.__assert_rule_has_valid_notification_strategies(rule, notification_strategies)

        assert len(source_service_snapshot) == migrated_record_count

    def __get_all_rules(self) -> List[Dict[str, Any]]:
        response = self.get(GET_CALIBRATION_RULES_ROUTE)
        response.raise_for_status()

        return response.json()['calibrationRules']

    def __create_test_notification_strategy(self) -> str:
        result = NotificationUtilities().create_simple_smtp_notification_strategy(
            self,
            f'Notification strategy for {TEST_NAME}',
            'Test notification strategy')

        return result['notification_strategy']['id']

    def __modify_existing_rule(
        self,
        workspace_id: str,
        notification_strategy_id: str,
        existing_rules: List[Dict[str, Any]]
    ):
        existing_rule = self.__find_calibration_rule_for_workspace(workspace_id, existing_rules)
        existing_rule['severityLevels'].append(self.__create_test_severity_level(notification_strategy_id))

        uri = MODIFY_CALIBRATION_RULES_ROUTE_FORMAT.format(rule_id=existing_rule['id'])

        response = self.put(uri, json=existing_rule)
        response.raise_for_status()

    def __create_test_severity_level(self, notification_strategy_id: str) -> Dict[str, Any]:
        return {
            'name': 'Test',
            'severityLevel': 1,
            'daysUntilCalibrationDue': 1,
            'notificationStrategyIds': [notification_strategy_id]
        }

    def __assert_rules_equal(self, expected: Dict[str, Any], actual: Dict[str, Any], strict: bool):
        if strict:
            assert expected == actual
        else:
            # Minimal checks for a rule we didn't create.
            assert expected['displayName'] == actual['displayName']
            assert expected['description'] == actual['description']

    def __assert_rule_has_valid_workspace(self, rule: Dict[str, Any], workspaces: List[str]):
        matching_workspace = next((workspace for workspace in workspaces if workspace == rule['workspace']), None)
        assert matching_workspace is not None

    def __assert_rule_has_valid_notification_strategies(
        self,
        rule: Dict[str, Any],
        notification_strategies: List[Dict[str, Any]]
    ):
        for level in rule['severityLevels']:
            if level['name'] == 'Test':
                assert len(level['notificationStrategyIds']) > 0

            for strategy_id in level['notificationStrategyIds']:
                matches = (strategy for strategy in notification_strategies if strategy['id'] == strategy_id)
                assert next(matches, None) is not None

    def __find_calibration_rule_for_workspace(
        self,
        workspace_id: str,
        rules: List[Dict[str, Any]]
    ) -> Dict[str, Any]:
        rule = next((rule for rule in rules if self.__is_calibration_rule_for_workspace(workspace_id, rule)), None)
        if rule is None:
            raise RuntimeError(f'Failed to find Calibration rule for workspace {workspace_id}')
        return rule

    def __is_calibration_rule_for_workspace(self, workspace_id: str, rule: Dict[str, Any]) -> bool:
        return rule['displayName'] == 'Calibration' and rule['workspace'] == workspace_id

    def __find_rule_by_display_name(
        self,
        rule: Dict[str, Any],
        collection: List[Dict[str, Any]]
    ) -> Optional[Dict[str, Any]]:
        return self.find_record_with_matching_property_value(rule, collection, 'displayName')


if __name__ == '__main__':
    handle_command_line(TestAssetRule)
